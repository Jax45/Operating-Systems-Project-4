Deliverables
1. Have oss create a process control table with one user process (of real-time class) to verify it is working
Done
2. schedule one user process over and over, logging the data
Done
3. Create the round robin queue, add additional user processes, making all the user processes alternate in it.
	Need user process to not take up all time
        Need user process to output throughput
	NEED oss to keep track of if done or still working

4. keep track of and output statistics like thorughput, idle time, etc

5. implement an additional user class and the multilevel feedback queue
	USER CLASS?
        priority, zero, one, two,
6. add the chance for user processes to be blocked on an event. keep track of stats on this
	inside scheduling the [0,3] thing.


Questions:
    do the processes have to be generated and launched between dispatches?
        ask for basic flow
    should the generate processes be 1.xx 2.xx 3.xx for 3 processes at one time or all laucnhed at same time
    how to come up with launch time if bitmap is full?
          If your process table is already full when you go to generate a process, just skip that generation, but do determine
          another time in the future to try and generate a new process.
    entire Scheduling section
    

todo:
random numbers are all generated
user.c updates the pcb
oss.c keeps track of the user's time and outputs it
oss.c bitmap is a char unsigned bitmap
oss.c will kill after so many seconds
oss.c will wait after 100 spawned before spawning anymore.
user.c will have the wait time written out
user.c will have event working
user.c will have random 0-3 working.



Updated todo:
Fix the bitmap kill in oss.
0 not generated til after 50 ms
take out extra launch step
rework queue to deq and enq
add bitmap
add wait time
add start time
add cpu time
add functions for queue (avgwait and count);

